# Processors scheduler
## Условия:
Требуется написать реализацию интерфейса `Runner`, удовлетворяющую контракту интерфейса:

```java
public interface Runner<T> {
    /**
     * Runs a set of interdependent processors many times until null is produced by any of them
     *
     * @param maxThreads    - maximum number of threads to be used
     * @param maxIterations - maximum number of iterations to run
     * @param processors    - a set of processors
     * @return a map, where the key is a processor id, and the value is a list of its outputs in the order of iterations
     * @throws ProcessorException if a processor throws an exception, loops detected, or some input ids not found
     */
    Map<String, List<T>> runProcessors(Set<Processor<T>> processors, int maxThreads, int maxIterations) throws ProcessorException;
}
```

Реализация должна удовлетворять следующим требованиям:
- Задача метода `runProcessors` – запускать весь набор «процессоров» в несколько итераций (не более `maxIterations`)
 и возвратить список результатов каждого для всех полных итераций;
- В рамках каждой итерации ни один «процессор» не запускается пока не будут
 запущены все те, что соответствуют его `input ids`;
- Некоторые «процессоры» возвращают пустые списки `input ids`,
 они являются источником данных и могут запускаться сразу;
- «Процессоры» могут (и должны) выполняться в несколько потоков, но не более чем `maxThreads`;
- В каждой итерации каждый «процессор» запускается ровно один раз;
- Может запускаться больше одной итерации одновременно, но ни один «процессор»
 не может запускаться параллельно самому себе;
- Последовательность итераций для каждого «процессора» должна соблюдаться, то есть он не может
 быть запущен в итерации, если еще не завершился в предыдущей;
- Если хоть один «процессор» кидает исключение, все остальные потоки должны прерываться
 и `runProcessors` тоже должен кидать исключение;
- Также `runProcessors` должен кидать исключение, если граф зависимостей содержит циклы или неизвестные `input ids`
- Если хоть один «процессор» возвращает `null`, результаты этой и всех последующих (если они уже запущены)
 итераций должны игнорироваться и `runProcessors` должен возвращать результат всех предыдущих итераций;

## Теоретическая часть

Реализацию вышеуказанного задания можно разбить на три основных части:

### Препроцессинг
Этап препроцессинга переводит `Set<Processor<T>>` в более удобное для дальнейшего использования
представление, а также проверяет граф зависимостей процессоров на ацикличность и
отсутствие неизвестных зависимостей.

#### Ацикличность

Граф зависимосте проверяется на ацикличность при помощи одного обхода в глубину.
Изначально все вершины покрашены в чёрный. Когда мы входим в вершину, мы красим
её в серый, когда выходим из вершины, красим в белый, в белые вершины мы больше
не входим. Если в какой-то момент мы должны войти в серую вершину, то мы нашли
цикл, так как от этой вершины существует путь в саму себя.

### Формирование планировщика
Планировщик, или *очередь задач*, будет тем объектом/процессом, который раздаёт 
задачи исполнителям, сохраняет результаты их выполнения и следит за исключениями и
`null`-ответами. Для описания контрактов планировщика мной был создан интерфейс
`TaskQueue`, а для передачи его в исполнителя — интерфейс `TaskQueueCreator`. Мной
было придумано две различных очереди заданий:

#### [Confident task queue](src/main/java/ru/covariance/jbintern/queue/confident)
Все процессоры добавляются в очередь сразу же, как только их становится можно
запустить:
- При инициализации очереди, если этот процесс является источником данных;
- При завершении исполнения этого процессора в предыдущей итерации, так как
процессор не может выполнятся парралельно сам себе;
- При завершении исполнения всех процессоров этой эпохи, которые предоставляют 
входные данные для этого.

##### Преимущества:
 * Очередь всегда по максимуму заполнена, простои могут случится только если
 порядок исполнения неоптимален.
##### Недостатки:
 * Если какой-то процессор возвращает `null` или исключение, то может оказаться,
 что мы выполнили слишком много лишней работы.
 
#### [Iterative task queue](src/main/java/ru/covariance/jbintern/queue/iterative)
Итерации выполняются последовательно — следующая итерация не начинает выполняться,
пока не закончились все операции предыдущей. 

##### Преимущества
 * Объем лишней работы при возврате `null` одним из процессоров минимален.

##### Недостатки
 * Не гарантируется постоянное заполнение очереди. Если у графа процессоров есть
 *бутылочное горлышко*, то простои могут быть очень существенными.

### Выполнение процессов
Для выполнения процессов мной были придуманы три различные политики, эффективность
которых на различных входных данных существенно различается.

#### Boss policy
Существует главный тред, который выдаёт всем остальным тредам задачи. Сам он выполняет задачи
только если других доступных тредов нет.

##### Преимущества:
 * Если доступных тредов много, эта политика будет весьма эффективна, так как все потоки
 будут загружены практически всё время.
##### Недостатки:
 * Если доступных тредов мало, то тред-босс будет простаивать существенную часть времени.
 * Требуется писать отдельную реализцию на случай, если доступных тредов нет, так как тогда
 треду-боссу придётся выполнять все задачи самому.

#### Leader policy
Существует главный тред, который, распределив задачи между остальными тредами,
 берёт задачу и себе и не раздаёт новых задач, пока не выполнит её.

##### Преимущества:
 * Тред-лидер никогда не простаивает, что может быть очень выгодно при малом количестве 
 доступных тредов. Для любого количества тредов код остаётся одинаковым.
##### Недостатки:
 * Так как остальным тредам приходится дожидаться того, как основной тред закончит свою задачу,
 то они могут простаивать существенное время, дожидаясь, пока им выдадут новую задачу. Этот недостаток
 становится особенно существенным при большом количестве тредов.
 
#### [Anarchist policy](src/main/java/ru/covariance/jbintern/policies/anarchist)
Существует тред, стартующий остальные и подводящий итоги, в остальном треды равноправны,
также существует единый объект, распределяющий задачи. По окончании
своей задачи каждый тред пытается захватить объект и получить новую задачу для себя,
иначе ждёт, пока задача не появится.

##### Преимущества:
 * Треды простаивают только если новых задач попросту пока что нет или в очереди за
 распределителем задач. 
 * Не выделяется отдельный главный тред, от перфоманса которого зависят все остальные.
##### Недостатки:
 * При большом количестве тредов и простых(быстрых) задачах эффективность заметно снижается,
 так как бОльшая часть времени тратится на стояние в очереди за распределителем.
##### Возможные улучшения:
 * Единственное время простоя это время ожидания захвата очереди.
 При большом количестве потоков это становится крайне существенно.
 Возможные улучшения этого момента:
    - Вдохновляясь протоколами когеррентности кэшей, можно сделать
    несколько экземпляров объекта очереди, которые будет синхронизироваться
    между собой, когда никто не пытается их захватить.
    - Можно делить граф процессоров на несколько частей, которые
    слабо зависят друг от друга и каждому назначать свой экземпляр
    очереди.
 * Может оказаться, что порядок исполнения внутри самой очереди
  неоптимален, и из-за этого у нас возникают искуственные
  *бутылочные горлышки*. Вдохновляясь идеями, лежащими в основе альтернативы конвейрного
  исполнения - суперскалярной архитектуры, можно оптимизировать очередь,
  запоминая информацию о предыдущих итерациях. 
## Практическая часть
Были реализованы обе вышеописанные очереди задач (названия кликабельны).
Из политик поведения была реализована только анархистская.

Также реализовано достаточно большое количество различных тестов.
Подробнее о них [тут](src/test/java/README.md).

Запускаются тесты при помощи `maven-surefire-plugin` командой 
`mvn test`.